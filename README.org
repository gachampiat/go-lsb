#+TITLE: Travaux pratiques : Stéganographie
#+AUTHOR: Gabriel Champiat
#+DATE: 2020-04-21
#+titlepage:true
#+toc:true
#+lof:true
#+logo:images/logo.png
#+titlepage-rule-color:419932
\pagebreak

* Introduction
Dans le cadre de nos cours à l'Ecole Nationale Supérieure d'Ingénieurs de Bretagne Sud, nous
avons eu une introduction à la Stéganographie. Afin de nous exercer dans ce domaine, nous avons
dû implementer un programme permettant de mettre en place une LSB. 

L'objectif d'une LSB est d'insérer des données dans les bits de poids faible de chaque octet composant
l'image. En effet, avec une insertion de ce type, nous ne pouvons pas faire la distinctions à l'oeuil
nu.

Dans un premier temps, nous détaillerons la conception de notre programme en expliquant notamment l'insertion
des données et la récupération des données. Puis nous continuerons par expliquer comment nous avons mis
en place la déctéction d'une LSB dans une image. Puis nous finirons par la présentation des courbes ROC
obtenues avec notre fonction de détéction.


* Technique LSB

** Architecture
Dans un premiers temps, le programme a été ecrit en Golang, il faudra donc pour l'utiliser passer par une phase de compilation.
Nous avons choisi ce langage, pour plusieurs raisons. La première de celle-ci est qu'il nous permet de compiler le même code
pour différentes architectures ce qui est très plaisant. De plus nous souhaitons avoir un programme prêt à l'utilisation, sans
l'installation de dépédences. Et enfin car ce TP nous a permit de mettre en oeuvre nos conaissances théorique sur ce langage.


Afin de rendre notre conception évoluable, nous sommes parti sur l'utilisation du patron de conception "Décorateur".
En effet grâce à ce patron de conception, nous pourrons par la suite rajouter des fonctionnalités à notre programme.


** Insertion

La première étape de l'insertion est de vérifier que le stego-médium possède assez d'octets pour acceuillir la taille du
message. Pour cela, il nous suffit de multiplier par 8 la taille du message pour avoir sa taille en bits, puis de comparer
cette valeur avec le nombre d'octets disponnible dans l'image. Cette étape permet de calculer le taux stéganographique.

Dans notre cas nous rajouter au message d'origine une entête de 8 octets permettant de définir la taille du message, 
ce qui nous sera utile lors de récupération du message.

Pour le chiffrement des données, nous avons mis en place l'algorithme de chiffrement RC4. Nous avons choisi un algorithme
de chiffrement par flux pour la simple et bonne raison d'éviter des rajouter de la taille à notre message, par exemple
l'utilisation du chiffrement AES va augmenter la taille du message et donc faire augmenter le taux stéganographique, ce qui
a pour conséquence d'augmenter la probabilité de détéction.

Mainteant pour l'insertion des données, il suffit de parcourir tous les octets de l'image afin d'insérer chaque bit du message.
Pour parcourir les octets le programme fonctionne de deux manières différentes. La première lorsque l'utilisateur de saisie par
de graine, alors le programme va lire les octets les uns à la suites des autres. Si l'utilisateur saisie une graine, alors le programme
va simplement tirer des nombres "aléatoire" depuis cette graine pour choisir l'emplacement de l'octet. Afin de simplifier l'utilisation 
du programme la graine devra être sous forme de chaine de caractère qui sera par la suite transformé en entier.

Ensuite pour l'insertion, nous réalisons la technique de LSB Replacement, c'est-à-dire que peu importe la valeur du bit de poid faible
de l'octet, nous allons le remplacer la par valeur du bit que nous souhaitons insérer.

Pour vérifier que l'algorithme fonctionne bien, vous pouvez essayer d'insérer un message dans un stego-médium, puis d'ouvrir la nouvelle 
image genèré, aucun changement visible ne devrait être aperçu, pourtant les données sont biens là.


** Récupération

Maintenant que nous avons vu comment notre programme inséré les données, nous allons voir comment celui-ci les récupérer. La première 
étape est de récupérer la taille du message qui est stockée dans un header. 

Comme pour l'insertion pour parcourir les octets de l'image deux choix sont possible soit l'utilisateur n'a pas saisi de graine, dans ce
cas là, le programme va lire à la suite. Sinon comme pour l'insertion via une graine sous forme de chaine de caractère, le programme
va lire des octets de manière "aléatoire".

Une fois la taille de message récupérée, il suffit, à l'aide d'une boucle de récupérer tous les octets nécessaires, à l'aide du même fonctionnement
décrit juste avant. Une fois que nous avons le message, celui-est déchiffré si l'utilsateur a saisie une clé. 

Dans tous les cas, le message est affiché sur la sortie standard de l'utilisateur.


** Detéction
Comme vous avez pu le voir lors de l'insertion, le LSB est quasi indétectable à l'oeil nu, mais ce n'est pas pour autant que nous ne
pouvons pas le detecter. En effet, il est possible de detecter l'insertion de données grâce à une étude statistique du nombre de bits
de poid faible avec la valeur 0 ou 1. 

Attention, comme tous les tests stastiques, celui-ci dépend grandement du taux stéganographique et du stégo-médium choisi. 

Pour réaliser cette détection nous allons utiliser l'algorithme Sample Pair Analysis (SPA). Dans notre implementation de l'algorithme,
nous allons comparé pour tous les pixels (i.e 3 octets) de l'image leurs valeurs RGB avec le pixel voisin. En effet, cette détection
se base sur le faite que stastiquement deux pixels voisins dans une image auront des valuers semblable. 


TODO : EXPLIQUER PLUS EN DETAILS SON FONCTIONNEMENT.


* Courbes ROC
Afin de mettre à l'épreuve notre fonction de détéction, nous allons créer des courbes ROC à partir des
résultats de celui-ci. En effet ces courbes servent à caractérisée la performance d'un test binaire,
c'est-à-dire un test qui renvoie vrai ou faux. Notre fonction de détéction est bien un test binaire, 
car celle-ci indique si oui ou non l'image est un stégo-médium.

Pour tracer les courbes nous placerons en absicisse les faux positifs et en ordonnées les vrais positifs.

Maintenant, nous allons nous procurer notre jeu de données afin de réaliser des tests. Pour cela, nous
allons nous utiliser le site suivant https://picsum.photos/. Maintenant que nous avons nos images, avec
un simple programme python, nous allons utiliser notre binaire Golang. 

Le fonctionnement du programme python est le suivant, nous allons parcourir notre dataset d'image (dans notre cas 100 images)
et insérer de la données dans ces images avec des taux stéganographiques différents. Dans un premiers temps, nous ferons avec
un taux stéganographique de 5%. Maintenant que nous avons les stégo-cover et les stégo-médium, nous allons pour chaque catégorie
d'image exécuter notre fonction de détection puis l'on stocke les résultats. 

Ensuite on fait varier le taux à partir duquel l'image est considérer comme stégo-médium.
Cette variation a un pas de 0.01 et est borné entre 0 et 1. Pour chaque variation, nous allons calculer le nombre de vrai positif et
le nombre de faux positif. Nous appellons un vrai positif quand la détéction indique de la données dans un stégo-médium et inversement,
un faux positif quand la fonction indique de la données dans un stégo-cover. Pour finir, nous divisions la valeur de vrai positif et de
faux positif par le nombre d'image correspondant à chaque catégorie, c'est-à-dire au nombre d'image considérees comme stego-médium et
stégo-cover. Dans notre cas il s'agit de cent images pour chaque catègorie. 

Une fois que nous avons réalisée tous les calculs, il suffit simplement d'afficher les résultats sur un courbe. 

#+CAPTION: Courbe ROC
#+NAME:    Courbe ROC
[[./images/courbe_roc.png]]
 
Afin de comparer nous avons réaliser les courbes ROC avec des insértions aléatoires.

#+CAPTION: Courbe ROC avec aléatoire
#+NAME:    Courbe ROC avec aléatoire
[[./images/courbe_roc_seed.png]]


* Conclusion


* Annexes


* Source
  - http://www.goprod.bouhours.net/?page=pattern&pat_id=8
